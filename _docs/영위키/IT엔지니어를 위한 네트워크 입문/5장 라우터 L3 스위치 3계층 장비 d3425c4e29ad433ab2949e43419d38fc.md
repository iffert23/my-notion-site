# 5장/ 라우터/L3 스위치: 3계층 장비

---

기존: 라우터=소프트웨어로 구분, 스위치=하드웨어로 구분

기술 발달로 인해 L3  스위치와 라우터를 구분할 수 없다.

### 5.1 **라우터의 동작 방식과 역할**

라우터는 들어온 패킷의 목적지 주소가 라우팅 테이블에 없으면 패킷을 버린다(스위치와 반대, 스위치는 목적지 주소가 MAC 테이블에 없으면 브로드캐스트 한다.)

5.1.1 경로 지정

IP주소를 확인해 원격지에 있는 적절한 경로로 패킷을 포워딩한다.

경로 정보를 얻는 역할과 경로 정보 확인 후 패킷을 포워딩하는 역할로 나뉘어서 수행한다.

정확한 목적지 경로를 얻는 것이 제일 중요하며 IP주소를 입력하며 자연스럽게 인접 네트워크 정보를 얻는 방법과 라우터끼리 서로 경로 정보를 자동으로 교환하는 방법이 있다.

라우팅 테이블에서는 목적지IP와 Next Hop을 고려한다.

5.1.2 브로드캐스트 컨트롤

라우터는 패킷을 원격지로 보내는 것을 목표로 개발되어, 분명한 목적지 정보가 있을 때만 통신을 허용한다. 

이 때 브로드캐스트/멀티캐스트는 라우터의 입장에서는 정보를 습득할 수 없는 쓸모 없는 패킷인데 이 패킷이 다른 네트워크에 전파된다면 인터넷에 쓸모 없는 패킷이 가득 차 통신불능 상태가 될 수 있다.

⇒ 브로드캐스트가 다른 네트워크로 전파되는 것을 막는 기능을 브로드캐스트 컨트롤이라고 한다.

네트워크상에 브로드캐스트가 많이 발생하는 경우, 라우터로 네트워크를 분리하면 브로드캐스트를 분할해서 네트워크 성능을 높일 수 있다.

5.1.3 프로토콜 변환

과거 네트워크 환경에서는 WAN과 LAN이 사용하는 프로토콜이 완전히 달랐기 때문에 네트워크를 구성하기 위해서 LAN 기술이 WAN 기술로 변환되어야 했고 이런 역할을 라우터가 담당했다.

라우터에 패킷이 들어오면 라우터는 2계층까지의 헤더 정보를 벗겨내고 3계층 헤더를 확인한 다음 2계층 헤더를 새로 만들어 외부에 내보낸다.

(추측) 2계층 헤더 정보를 새로 만들어서 내보낼 때 2계층 헤더가 있던 자리에 WAN 프로토콜로 변경하는 방식이 아닐까 싶다

### 5.2 경로 지정 - 라우팅/스위칭

5.2.1 라우팅 동작과 라우팅 테이블

인접한 라우터까지만 경로를 지정하면 인접 라우터에서 최적의 경로를 다시 파악한 후 라우터로 패킷을 포워딩하는 기법을 홉 바이 홉(Hop-by-Hop)이라고 하고, 인접한 라우터를 넥스트 홉(Next Hop)이라고 부른다

- 넥스트 홉 지정 방법
- 다음 라우터의 IP를 지정한다 (일반적)
- 라우터의 나가는 인터페이스를 지정한다 (특수한 경우에만 사용, 넥스트 홉 라우터의 IP를 모르더라도 MAC 주소 정보를 알아낼 수 있을 때만 사용할 수 있다)
- 라우터의 나가는 인터페이스와 다음 라우터의 IP를 동시에 지정한다.
(인터페이스를 설정할 때는 물리 인터페이스를 지정하는 것이 일반적이지만 IP주소와 인터페이스를 동시에 사용할 때는 VLAN 인터페이스같은 논리적인 인터페이스를 사용할 수 있다)

*PPP : 

*HLDC : 

라우터가 패킷을 포워딩하기 위해 경로를 설정할 때는 출발지를 고려하지 않기 때문에 라우팅 테이블을 만들 때는 목적지 정보만 수집한다. 

라우팅테이블에 저장하는 데이터 : 목적지 주소, 넥스트 홉 IP 주소, 나가는 로컬 인터페이스(이건 선택사항)

PBR, Source Routing, Policy Routing : 라우터에서 패킷의 출발지 주소를 이용해 라우팅하는 기능.
→ 목적지 주소만 수집하는 라우터에서는 기능 활성화 불가능 (당연함)
→ 라우터 정책과 관련된 별도 설정이 필요한데 이 경우에 다른 라우터로의 전파가 어렵고 라우터에 일반적이지 않은 별도 동작이 필요하다]
→ 관리가 어려워지고 문제가 발생하면 해결이 어려우므로 특별한 목적으로만 사용한다.

근데 엄밀히 말하면 PBR, Source Routing, Policy Routing이 의미하는 바가 조금씩 다 달라서 따로 알아볼 필요성이 있다.
*PBR : 
*Source Routing : 
*Policy Routing : 

TTL : 3계층 IP 헤더에 있는 패킷의 Live(살아있을 수 있는) 시간(Hop)을 제한한다. 하나의 Hop 을 지날때마다 값이 1씩 줄어들며, 수명 값(TTL값)이 0이 되면 네트워크 장비에서 버려진다.

라우팅 루프 : 두 라우터가 서로에게 지속적으로 패킷을 포워딩하는 현상 (스위치 루프랑 똑같다)

스위치에서는 STP를 통해서 루프를 방지했고, 라우터에서는 TTL을 통해 루프를 방지한다.

5.2.2 라우팅(라우터가 경로 정보를 얻는 방법)

1. 다이렉트 커넥티드
    
    인터페이스에 IP를 입력하면 자동 생성되는 라우팅 테이블
    
    강제로 정보를 삭제할 수 없고, 해당 네트워크 인터페이스가 비활성되어야 자동으로 삭제된다.
    
2. 스태틱 라우팅
    
    관리자가 라우터에 직접 경로를 입력하는 방식
    
    다이렉트 커넥티드같이 연결된 인터페이스가 삭제되거나 비활성화되면 관련 정보가 자동으로 삭제되지만 논리적인 인터페이스는 함께 비활성화/삭제되지 않는 경우가 있다.
    
    단점 : 관리해야 할 네트워크의 수가 많아지거나 연결이 복잡해지면 관리자가 라우팅 정보를 하나하나 확인해서 수정/삭제해야 한다.
    
3. 다이나믹 라우팅
    
    스태틱 라우팅의 단점을 보완해준다.
    
    ⇒ 라우터끼리 자신이 알고있는 경로 정보 또는 상태 링크를 서로 교환하는 방식을 통해 전체 네트워크를 학습한다.
    
    상태 정보가 변경될 때나 주기적으로 라우터끼리 정보공유가 이루어지기 때문에 장애 발생 시에 상황을 빠르게 인지하여 대체 경로로 패킷을 포워딩할 수 있다.
    
    다이나믹 라우팅은 하나가 아니라 세부적으로 여러 종류로 분류할 수 있다. 
    
    → 다양한 경로를 체계적으로 데이터베이스화하고 순위를 적절히 부여해 최선의 경로 정보만 수집해두는데, 패킷 포워딩 시 최적 경로정보를 단순화하기 위해서 별도 테이블에 미리 보관해놓는다.
    
    여기서 라우터가 수집한 경로 정보(Raw Data)를 토폴로지 테이블이라고 하고, 이 경로 중 최적의 경로를 저장하는 테이블을 라우팅 테이블이라고 한다.
    
    이러한 라우팅 테이블을 바탕으로 빠르게 최적경로로만 포워딩하기 위해서 홉 바이 홉 방식을 사용한다. 빠른 경로로 다음 라우터에 패킷을 넘기면 해당 패킷을 받은 라우터에서 가지고있는 빠른 경로로 다음 라우터에 패킷을 넘긴다.
    

5.2.3 스위칭(라우터가 경로를 지정하는 방법)

3계층인 라우터가 라우팅 테이블을 참조해 라우터 외부로 패킷을 포워딩하는 작업을 스위칭이라고 한다.

만약 들어온 패킷의 목적지가 라우팅테이블에 있는 정보와 일치하지 않을 때는 롱기스트 프리픽스 매치 기법을 사용한다.

*롱기스트 프리픽스 매치(LPM) : 라우터가 패킷을 포워딩할 때 갖고 있는 라우팅 테이블 중에서 가장 좋은 항목을 찾는 알고리즘

단점 : 부정확한 정보 중 가장 비슷한 경로를 찾는 작업은 많은 부하가 걸린다. 

이 단점을 커버하기 위해 한 번 스위칭을 수행한 정보를 캐시에 저장하고, 뒤에 들어오는 패킷은 라우팅 테이블 확인 전에 캐시를 먼저 확인해서 캐시에 저장된 정보를 통해 스위칭을 수행한다.

5.2.4 라우팅, 스위칭 우선순위

우선순위 : 다이렉트 커넥티드 → 스태틱 라우팅 → 다이나믹 라우팅(어떤 라우팅 프로토콜을 통해 경로 정보를 얻었는가에 따라 다이나믹 라우팅 안에서도 우선순위가 나뉜다)

![시스코 기준 라우팅별 가중치 값](5%EC%9E%A5%20%EB%9D%BC%EC%9A%B0%ED%84%B0%20L3%20%EC%8A%A4%EC%9C%84%EC%B9%98%203%EA%B3%84%EC%B8%B5%20%EC%9E%A5%EB%B9%84/Untitled.png)

시스코 기준 라우팅별 가중치 값

AD(Administractive Distance, 관리 거리) : 기본적인 우선순위는 위처럼 정해져 있지만, 필요에 따라 관리자가 우선순위를 조정할 수 있다. 라우터 생산업체마다 AD값이 조금씩 다르다.

라우팅 우선순위 : 롱기스트 매치(스위칭) → AD → Cost → ECMP(부하 분산)

### 5.3 라우팅 설정 방법

5.3.1 다이렉트 커넥티드

목적지가 외부 네트워크인데 다이렉트 커넥티드 정보만 있으면 외부 네트워크와 통신이 불가능하다.

외부 네트워크에 대한 라우팅 정보가 있더라도 다이렉트 커넥티드 정보를 잘못 입력하면 외부 네트워크와 통신할 수 없다.

5.3.2 스태틱 라우팅

config 입력 문법

시스코 : `ip route [source ip address] [subnetmask] [destination ip address]`

리눅스 : `route add -net [ip address /prefix] gw [gateway address]`

default routing : 목적지 주소의 subnetmask가 모두 0인 스태틱 라우팅 → 모든 네트워크

5.3.3 다이나믹 라우팅

![다이나믹 라우팅 프로토콜 분류](5%EC%9E%A5%20%EB%9D%BC%EC%9A%B0%ED%84%B0%20L3%20%EC%8A%A4%EC%9C%84%EC%B9%98%203%EA%B3%84%EC%B8%B5%20%EC%9E%A5%EB%B9%84/Untitled%201.png)

다이나믹 라우팅 프로토콜 분류

최근에는 OSPF와 BGP 프로토콜이 사용된다.

멀티캐스트 라우팅 프로토콜 : DVMRP, MOSPF, PIM

유니캐스트 라우팅 프로토콜 : RIP, IGRP, OSPF, IS-IS, EIGRP, BGP

5.3.3.1 역할에 따른 분류

인터넷에는 AS(Autonomous System)이라는 자율 시스템이 존재하며, LG U+, KT와 같은 인터넷 사업자가 한 개 이상의 AS를 운영한다.

AS 내부에서 사용하는 라우팅 프로토콜을 IGP라고 하고, AS간 통신에 사용하는 라우팅 프로토콜을 EGP라고 한다.

AS 내부에서는 효율성을 중시하여 자체적으로 규칙을 세워 운영할 수 있지만, 다른 AS간 연결에서는 효율성보다 조직 간 정책이 더 중요하기 때문에 EGP에 이런 통신을 정책적으로 조정할 수 있는 기능이 있어야 한다.

5.3.3.2 동작 원리에 따른 분류

IGP 프로토콜

- Distance Vector ⇒ RIP, BGP
    
    Advensed Distance Vector ⇒ IGRP, EIGRP
    
    인접한 라우터에서 경로 정보를 습득
    
    인접하지 않은 라우터의 정보는 인접 라우터를 통해 한 다리 건너서 전달받는다.
    
    → 그렇기 때문에 먼 라우터의 정보를 전달받는데까지의 시간이 오래 걸린다.
    
- Link-State ⇒ OSPF
    
    라우터에 연결된 링크 상태를 서로 교환하고 각 네트워크 맵을 그림
    
    직접적인 상태 정보를 받을 수 있어서 이런 상태를 교환해서 토폴로지 데이터베이스를 만든 후 SPF(Shortest Path First) 알고리즘을 이용해 최단 경로 트리를 만들고 그 중 최적의 경로를 선정해 라우팅테이블에 해당 정보를 추가한다.
    
    → 전체 네트워크 맵을 그리고 경로 변화를 파악하는데에 많은 리소스가 소모된다.
    
    → 네트워크 변화를 더 빨리 감지하기 위해서 네트워크를 AREA 단위로 분리하고 해당 AREA 내에서만 링크 상태 정보를 교환한다.
    
    ![참고](5%EC%9E%A5%20%EB%9D%BC%EC%9A%B0%ED%84%B0%20L3%20%EC%8A%A4%EC%9C%84%EC%B9%98%203%EA%B3%84%EC%B8%B5%20%EC%9E%A5%EB%B9%84/Untitled%202.png)
    
    참고