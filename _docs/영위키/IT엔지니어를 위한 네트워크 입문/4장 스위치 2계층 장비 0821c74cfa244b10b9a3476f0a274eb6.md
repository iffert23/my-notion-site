# 4장/ 스위치: 2계층 장비

---

### 4.1 스위치 장비 동작

**4.1.1 플러딩 Flooding**

스위치는 부팅하면 네트워크 정보가 아무것도 없다. → 허브처럼 동작

허브처럼 모든 포트로 패킷을 흘리는 동작 방식 = 플러딩

이런 동작이 많아지면 스위치가 제 역할을 못하게 되기 때문에 패킷이 스위치로 들어오면 해당 패킷의 MAC주소를 보고 테이블을 만든 후 패킷을 전송한다.

스위치에게 엉뚱한 MAC 주소를 습득시키거나 스위치의 MAC 테이블을 꽉 차게 만들어 플러딩을 유도하는 공격방식이 쓰이기도 한다

ARP 포이즈닝 기법 : 모니터링해야 할 IP의 MAC주소가 공격자 자신인것처럼 속여 원하는 통신을 받는 방법

**4.1.2 어드레스 러닝 Address Learning**

MAC 주소 테이블을 만들고 유지하는 과정

출발지  MAC 주소 정보를 이용해서 테이블에 기록한다.

브로드캐스트나 멀티캐스트에 대한 MAC 주소를 학습할 수는 없다.

확인방법 : `show mac address-table`

**4.1.3 포워딩/필터링 Forwarding/Filtering**

패킷이 스위치에 들어온 경우, 도착지 MAC 주소를 확인하고 자신의 MAC테이블과 비교해서 맞는 정보가 있으면 해당 포트로 패킷을 포워딩한다.

이때 다른 포트로는 패킷을 보내지 않는데 이것을 필터링이라고 한다.

⇒ 통신이 다른 포트에 영향을 미치지 않는다.

유니캐스트에 대해서만 포워딩과 필터링 작업을 수행하는데 BUM 트래픽에서는 전달이나 필터링을 하지 않고 모두 플러딩한다. 언노운 유니캐스트도 브로드캐스트와 동일하게 플러딩 동작한다.

### 4.2 VLAN

**4.2.1 VLAN이란?**

가상화 LAN 분할,구성 기술

각 부서별로 네트워크를 분할할 때 사용된다

VLAN간의 통신이 필요하다면 3계층 장비가 필요하다.

**4.2.2 VLAN의 종류와 특징**

포트 기반 VLAN : 어떤 단말이 접속하든지 스위치의 특정 포트에 VLAN을 할당하면 할당된 VLAN에 속하게 된다.

MAC 주소 기반 VLAN : 스위치에 연결되는 단말의 MAC 주소를 기반으로 VLAN 을 할당한다. 단말에 따라 VLAN 정보가 바뀔 수 있기 때문에 Dynamic VLAN이라고 부르기도 한다.

**4.2.3 VLAN 모드(Trunk/Access) 동작 방식**

⇒ 장비간의 연결만으로도 많은 포트가 낭비된다

여러 개의 VLAN이 존재하는 상황에서 스위치를 서로 연결해야 하는 경우, 각 VLAN 개수만큼 포트를 연결해야 하고 VLAN으로 분할된 스위치는 물리적인 별도의 스위치처럼 취급된다.

이를 해결하기 위해 VLAN 태그 기능을 사용함
: 하나의 포트에 여러 개의 VLAN을 함께 전송할 수 있게 하고, 태그 포트/트렁크 포트 라고 한다

이로 인해 MAC 테이블에 VLAN을 지정하는 필드가 추가되었고 하나의 스위치에서 VLAN을 사용하면 VLAN별로 MAC주소 테이블이 존재하는 것처럼 동작한다.

일반적인 포트 : 언태그 포트/엑세스 포트

### 4.3 STP

SPoF(Single Point of Failure : 단일 장애점, 하나의 요소 때문에 장애가 발생할 경우 전체 시스템이 장애가 발생하는 지점)로 인한 장애를 피하기 위한 노력을 한다. ⇒ 이중화, 다중화

단점 : 루프(Loop)

**4.3.1 루프란?**

두 대 이상의 스위치로 디자인하게 되면 패킷이 네트워크를 따라 계속 전송된다(두 대 이상의 장비가 서로 핑퐁하는것). 그러한 상황이 네트워크 마비를 만든다.

루프로 문제가 발생한다면 대부분 브로드캐스트 스톰으로 인한 문제다.

**4.3.1.1 브로드캐스트 스톰**

루프 구조로 네트워크가 연결된 상태의 단말에서 브로드캐스팅→스위치가 모든 포트로 플러딩→플러딩 된 패킷을 받은 스위치가 또다시 다른 포트로 플러딩

⇒ 이런 식으로 패킷이 계속 돌아가는 것을 브로드캐스트 스톰이라고 한다.

3계층 장비에서는 TTL이라는 패킷 수명이 있지만 2계층 장비에는 이러한 매커니즘이 없기 때문에 네트워크에 연결된 모든 단말이 브로드캐스트를 처리하기 위해 시스템 리소스를 계속 사용하면서 스위치와 네트워크에 연결된 단말간 통신이 거의 불가능한 상태가 된다.

상황 발생 시

1. 네트워크에 접속된 단말의 속도가 느려짐 (CPU 사용률이 높아짐)
2. 네트워크 접속 속도가 느려짐 (거의 통신 불가능)
3. 네트워크에 설치된 스위치의 모든 LED들이 동시에 빠른 속도로 깜빡임

**4.3.1.2 스위치 MAC 러닝 중복 문제**

브로드캐스트뿐만 아니라 유니캐스트도 문제를 일으킨다.

직접 전달되는 패킷과 스위치를 돌아 들어간 패킷의 포트가 달라 MAC 주소를 정상적으로 학습할 수 없기 때문에 중간에 있는 스위치에서도 MAC 러닝 문제가 발생한다.

⇒ MAC Address Flapping : 동일한 MAC 주소가 여러 포트에서 학습되면 MAC 테이블이 반복 갱신되어 정상적으로 동작하지 않는 현상

루프 예방방법 : 루프 구성 포트 중 하나의 포트만 Shutdown 되어 있으면 됨

그렇지만 루프를 찾아내는 것이 힘들며 네트워크에 장애가 발생하면 해당 포트를 수동으로 다시 사용하도록 만들어야 하기에 비효율적이기 때문에 STP가 개발되었다.

**4.3.2 STP란?**

루프를 확인하고 적절히 포트를 사용하지 못하게 만들어 루프를 예방하는 매커니즘

STP를 사용하기 위해서는 전체적인 스위치 연결상황을 파악해야 하기 때문에 BPDU라는 프로토콜을 사용해서 스위치간 정보전달 및 수집을 한다.

BPDU(브릿지 프로토콜 데이터 유닛) : 스위치가 갖고 있는 ID와 같은 고유값이 들어가고, 이러한 정보가 스위치간에 서로 교환되기 때문에 루프 파악이 가능하다.

**4.3.2.1 스위치 포트의 상태 및 변경과정**

- Blocking : 패킷 데이터 차단 후 BPDU를 기다림, 기본 교환주기는 2초이고 10번의 BPDU를 기다림, 20초의 Max Age동안 BPDU를 받지 못했거나 후순위 BPDU를 받았을 때 리스닝 상태로 변경.
- Listening : 포트가 전송 상태로 변경되는 것을 결정하고 준비함, 자신의 BPDU를 상태방에게 전송하기 시작, 총 15초 대기
- Learning : 이미 해당 포트를 포워딩하기로 결정하고 실제로 패킷 포워딩이 일어날 때 스위치가 곧바로 동작하도록 MAC주소를 학습, 총 15초 대기
- Forwarding : 패킷 포워딩 단계, 정상통신 가능

⇒ 총 50초 소요

링크 절체(전환)도 50초 소요되는데, Down된 포트가 자신의 포트일 경우 Max Age를 거치지 않기 때문에 30초만에 절체된다.

**4.3.2.2 STP 동작 방식**

1. 하나의 Root스위치 선정 (전체 네트워크 중 하나, 본인이 root일 경우 BPDU를 옆 스위치로 전달)
2. Root가 아닌 스위치 중 하나의 루트 포트를 설정 (루트 브릿지로 가는 가장 짧은 경로)
3. 하나의 세그먼트에 하나의 Designated 포트 선정 (스위치 간 연결에서 이미 Root 포트로 선정된 경우 반대쪽이 Designated 포트로 선정되며 양쪽 모두 포워딩상태, 스위치 간 연결에서 아무도 Root 포트가 아닐경우 한쪽은 Designated, 한쪽은 Alternated/Non-designated가 되어 차단 상태가 됨)

Root, Designated, Alternated

더 빠르게 단말과 네트워크를 연결하고자 한다면 Port Fast를 설정하면 되지만 너무 빠르게 포워딩상태가 되면 루프가 발생할 수 있기 때문에 BPDU가드 같은 기술이 사용되어야 한다

**4.3.3 향상된 STP(RSTP, MST)**

기존 STP의 장애요인을 해결하기 위함 (개거지같이 설명해놨네)

**4.3.3.1 RSTP**

STP 사용 시 포트의 상태 및 과정이 변경되기까지 소요되는 30~50초를 해결하기 위해 개발되었다.

절체 시간이 2~3초로 짧아서 일반적인 TCP 기반 애플리케이션이 세션을 유지할 수 있게 된다.

일반적인 형식은 STP와 동일하지만 BPDU 메시지 형식이 다양해졌기 때문에(STP에서 두 가지 메시지만 교환할 수 있다가 8가지의 메시지를 교환할 수 있게 됨) 여러 가지 상태 메시지를 교환할 수 있다.

![Untitled](4%EC%9E%A5%20%EC%8A%A4%EC%9C%84%EC%B9%98%202%EA%B3%84%EC%B8%B5%20%EC%9E%A5%EB%B9%84/Untitled.png)

8개의 메시지를 한꺼번에 보낼 수 있기 때문에 토폴로지 변경이 일어난 스위치 자신이 모든 네트워크에 토폴로지 변경을 직접 전파할 수 있다.

**4.3.3.2 MST**

일반 스패닝 트리 프로토콜은 CST라고 부르며 VLAN 개수와 상관없이 스패닝 트리 한 개만 동작하게 된다. 하지만 루프가 생기는 토폴로지에서 한 개의 포트와 회선만 활성화되므로 효율적인 자원 사용이 불가하다. (그리고 비효율적이다)

이 문제를 해결하기 위해 PVST가 개발되었고 VLAN마다 다른 스패닝트리 프로세스가 동작하므로 VLAN마다 별도의 경로와 트리를 만들 수 있게 되었다. (최적의 경로를 디자인할 수 있다, 각기 다른 블록 포트를 설정할 수 있게 되어 로드 셰어링이 가능해졌다)

하지만 STP 자체가 스위치에 많은 부담을 주는 프로토콜인데다가 VLAN별로 STP를 나누게 되다 보니 더 많은 부담이 되었고 이러한 단점을 보완하기 위해 MST가 개발되었다.

MST : 여러 개의 VLAN을 그룹으로 묶고(리전) 그 그룹마다 별도의 스패닝트리가 동작한다 ⇒ PVST보다 효율적

ex) 예를 들어 11~50 번 VLAN과 101~150번 VLAN이 있다면 11~50번을 하나의 리전으로, 101~150번을 하나의 리전으로 묶으면 두 개의 스패닝 트리로 100 개의 VLAN을 관리할 수 있다.

![SDN에 컨트롤 플레인, 데이터플레인 굉장히 중요. (기본개념으로 알고있어야 함) 추가적인 공부 필요](4%EC%9E%A5%20%EC%8A%A4%EC%9C%84%EC%B9%98%202%EA%B3%84%EC%B8%B5%20%EC%9E%A5%EB%B9%84/Untitled%201.png)

SDN에 컨트롤 플레인, 데이터플레인 굉장히 중요. (기본개념으로 알고있어야 함) 추가적인 공부 필요